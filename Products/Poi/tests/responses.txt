Responses
=========

Adapters
--------

Responses used to be Archetypes objects.  Not anymore.  They are light
weight Zope 3 objects now.  Before we switch to that we had better
make sure that they continue to work at least as good as they used to.
So some tests are in order.  First we make a response::

    >>> from Products.Poi.adapters import Response
    >>> res = Response(u"I cannot reproduce this error.")
    >>> res.creator
    '(anonymous)'
    >>> res.date
    DateTime('...')
    >>> res.changes
    []
    >>> res.add_change("review_state", "Transition", "unconfirmed", "confirmed")
    >>> res.changes
    [{'before': 'unconfirmed', 'after': 'confirmed', 'id': 'review_state', 'name': 'Transition'}]

That is everything we need to know about a response really, so our
basis is fine this way.

One thing that a PoiIssue does is being a container for responses.  We
can factor that out into an adapter.  We use annotations to do that,
so we need to load some zcml so Zope knows how to annotate an
AttributeAnnotatable object::

    >>> import Products.Five
    >>> from Products.Five import zcml
    >>> zcml.load_config('configure.zcml', Products.Five)
    >>> import zope.annotation
    >>> zcml.load_config('configure.zcml', zope.annotation)
    >>> from zope.annotation.interfaces import IAttributeAnnotatable

Now we make a mock issue (just to show that we do not need a full
blown PoiIssue) and turn it into a response container::

    >>> from Products.Poi.adapters import ResponseContainer
    >>> from zope.interface import implements
    >>> from Products.Poi.interfaces import IIssue
    >>> class MockIssue(object):
    ...     implements(IIssue, IAttributeAnnotatable)
    >>> issue = MockIssue()
    >>> rc = ResponseContainer(issue)
    >>> rc
    <Products.Poi.adapters.ResponseContainer object at ...>

This container does not have any responses yet, so let's do something
about that::

    >>> rc.highest == len(rc) == len(rc.items()) == 0
    True
    >>> rc.add(res)
    >>> rc.highest == len(rc) == len(rc.items()) == 1
    True

Adding something that is not an IResponse should fail::

    >>> rc.add("Bogus response.")
    Traceback (most recent call last):
    ...
    UnaddableError: Bogus response. cannot be added to <Products.Poi.adapters.ResponseContainer object at ...>: IResponse interface not provided.

The keys of the responses are successive numbers turned into unicode::

    >>> [k for k in rc.keys()]
    [u'1']
    >>> rc[u'1']
    <Products.Poi.adapters.Response object at ...>
    >>> u'1' in rc
    True
    >>> u'0' in rc
    False
    >>> for i in range(2, 12):
    ...     rc.add(Response("Response %d." % i))
    >>> [k for k in rc.keys()]
    [u'1', u'10', u'11', u'2', u'3', u'4', u'5', u'6', u'7', u'8', u'9']

That sort order leaves something to be desired.  We can fix that::

    >>> rc.sorted_keys()
    [u'1', u'2', u'3', u'4', u'5', u'6', u'7', u'8', u'9', u'10', u'11']
    >>> rc.highest == len(rc) == len(rc.items()) == 11
    True
    >>> rc.sorted_items()
    [(u'1', <...>), (u'2', <...>), (u'11', <...>)]
    >>> rc.sorted_values()
    [<Products.Poi.adapters.Response object at ...>, ...]
    >>> for val in rc.sorted_values():
    ...     assert(val in rc.values())
    >>> rc[u'7'].text
    'Response 7.'


Removing responses
------------------

Responses can be deleted::

    >>> rc.delete(u'7')
    >>> len(rc) == len(rc.items()) == 10
    True
    >>> rc.highest
    11

Non existing responses cannot be deleted::

    >>> rc.delete(u'7')
    Traceback (most recent call last):
    ...
    KeyError: u'7'

Deleting the most recent response should lower the highest id::

    >>> rc.delete(u'11')
    >>> rc.highest
    10

When the highest number is changed, a response with that id should be
available::

    >>> rc.delete(u'8')
    >>> rc.delete(u'9')
    >>> rc.highest
    10
    >>> rc.delete(u'10')
    >>> rc.highest
    6

Deleting the last one should not result in an error::

    >>> rc.delete(u'6')
    >>> rc.delete(u'5')
    >>> rc.delete(u'4')
    >>> rc.delete(u'3')
    >>> rc.delete(u'2')
    >>> rc.delete(u'1')
    >>> rc.highest
    0


Browser views
-------------

We have a browser view that takes care of showing the responses and
adding a response.  To properly test that, we really need a normal
PoiIssue within a PoiTracker.  To have this work we also need to load
a bit of acml::

    >>> import Products.Archetypes.Schema
    >>> zcml.load_config('configure.zcml', Products.Archetypes.Schema)
    >>> from Products.Poi.content.PoiTracker import PoiTracker
    >>> from Products.Poi.content.PoiIssue import PoiIssue
    >>> tracker = PoiTracker("issues")
    >>> tracker.issue = PoiIssue("one")
    >>> issue = tracker.issue

We get some very basic Plone functionality going here.  At least we
need some tools and set a Creator for this tracker::

    >>> from Products.CMFPlone.WorkflowTool import WorkflowTool
    >>> from Products.CMFPlone.URLTool import URLTool
    >>> from Products.CMFPlone.MembershipTool import MembershipTool
    >>> from Products.CMFPlone.CatalogTool import CatalogTool
    >>> tracker.portal_workflow = WorkflowTool()
    >>> tracker.portal_url = URLTool()
    >>> tracker.portal_membership = MembershipTool()
    >>> tracker.acl_users = MembershipTool()
    >>> class MockTransformData(object):
    ...     def __init__(self, text):
    ...         self.text = text
    ...     def getData(self):
    ...         return self.text
    >>> class MockTransforms(object):
    ...     def convertTo(self, target, text, mimetype=''):
    ...         return MockTransformData(text)
    >>> tracker.portal_transforms = MockTransforms()
    >>> tracker.portal_catalog = CatalogTool()
    >>> tracker.linkDetection = lambda x: x
    >>> tracker.Schema()['creators'].set(tracker, "manager")
    >>> tracker.getManagers()
    ('manager',)

We want to test some browser views.  So we need some test requests.
And a test request needs to be annotatable as we use memoize in some
parts::

    >>> from zope.publisher.browser import TestRequest
    >>> from zope.annotation.interfaces import IAttributeAnnotatable
    >>> from zope.interface import classImplements
    >>> classImplements(TestRequest, IAttributeAnnotatable)
    >>> request = TestRequest()

We need to have an adapter for our issues::

    >>> from zope.component import provideAdapter
    >>> from Products.Poi.adapters import IResponseContainer
    >>> provideAdapter(ResponseContainer, adapts=(IIssue,),
    ...                provides=IResponseContainer)
    >>> from zope.interface import classImplements
    >>> classImplements(PoiIssue, IAttributeAnnotatable)

We fire up a browser (view) and do some basic checking::

    >>> from Products.Poi.browser.response import Base
    >>> view = Base(issue, request)
    >>> view.available_severities
    ('Critical', 'Important', 'Medium', 'Low')
    >>> view.available_transitions
    ['']
    >>> view.available_releases
    <DisplayList [('(UNASSIGNED)', 'None')] at ...>
    >>> view.available_managers
    <DisplayList [('(UNASSIGNED)', 'None'), ('manager', 'manager')] at ...>

The view has some methods especially for displaying::

    >>> view.transitions_for_display
    [{'checked': 'checked', 'value': '', 'label': 'No change'}]
    >>> view.releases_for_display
    [{'checked': '', 'value': '(UNASSIGNED)', 'label': 'None'}]
    >>> view.managers_for_display
    [{'checked': 'checked', 'value': '(UNASSIGNED)', 'label': 'None'}, {'checked': '', 'value': 'manager', 'label': 'manager'}]

And of course the responses are visible.  Well, no response has been
added yet.

    >>> view.responses()
    []

We use a different browser view to add a response::

    >>> from Products.Poi.browser.response import Create
    >>> Create(issue, request)()
    >>> view.responses()
    [{'html': u'', 'response': <Products.Poi.adapters.Response object at ...>, 'id': u'1'}]

We create a slightly more interesting response::

    >>> form = dict(response="This issue misses a shrubbery.",
    ...             severity='Low')
    >>> Create(issue, TestRequest(form=form))()
    >>> len(view.responses())
    2
    >>> res = view.responses()[1]['response']
    >>> res.text
    'This issue misses a shrubbery.'
    >>> res.changes
    [{'before': 'Medium', 'after': 'Low', 'id': 'severity', 'name': 'Severity'}]
    >>> res.creator
    '(anonymous)'
    >>> res.date
    DateTime('...')
    >>> form = dict(response="We are no longer the Knights who say Ni.",
    ...             severity='Critical', responsibleManager='manager')
    >>> Create(issue, TestRequest(form=form))()
    >>> len(view.responses())
    3
    >>> res = view.responses()[-1]['response']
    >>> res.text
    'We are no longer the Knights who say Ni.'
    >>> res.changes
    [{'before': 'Medium', 'after': 'Critical', 'id': 'severity', 'name': 'Severity'}, {'before': '(UNASSIGNED)', 'after': 'manager', 'id': 'responsibleManager', 'name': 'Responsible manager'}]


Type of response
----------------

Responses have a type.  This can be used for showing them in a
different colour based on their type.  The default is 'additional'::

    >>> response = Response("text")
    >>> response.creator
    '(anonymous)'
    >>> res.type
    'additional'

Since we like to test this with fast unit tests, we need to set a
creator for the issue manually::

    >>> issue.Schema()['creators'].set(issue, "reporter")
    >>> issue.Creator()
    'reporter'

Within the Create view there is a method to determine the response
type.  Since the response was made anonymously, we stick to the
default::

    >>> createview = Create(issue, TestRequest())
    >>> createview.determine_response_type(response)
    'additional'

The original reporter of the issue can make a clarification::

    >>> response.creator = 'reporter'
    >>> createview.determine_response_type(response)
    'clarification'

A manager can reply::

    >>> response.creator = 'manager'
    >>> createview.determine_response_type(response)
    'reply'

Other persons can give additional information::

    >>> response.creator = 'Maurits'
    >>> createview.determine_response_type(response)
    'additional'


Migration
---------

For tests of the migration from old style to new style responses, see
migration.txt.
